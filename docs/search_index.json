[["index.html", "Collected R Code Introduction", " Collected R Code Phil Swatton Introduction This is a collection of R code written for the purposes of practice and demonstration. At the moment this is all in a work in progress stage, with a rough sketch set out for what the eventual contents will vaguely look like. "],["ordinary-least-squares.html", "Ordinary Least Squares", " Ordinary Least Squares ols &lt;- function(data, formula, method=&quot;QR&quot;, na.action=na.exclude) { mf &lt;- model.frame(formula, data, na.action=na.action) Y &lt;- model.response(mf, type=&quot;double&quot;) X &lt;- model.matrix(formula, mf) if (method == &quot;matrix&quot;) B &lt;- solve(t(X) %*% X) %*% t(X) %*% Y if (method == &quot;QR&quot;) { QR &lt;- qr(X) Q &lt;- qr.Q(QR) R &lt;- qr.R(QR) B &lt;- backsolve(R, t(Q)%*%Y) } return(B) } Testing the function: set.seed(42) N &lt;- 1000 X1 &lt;- rnorm(N) X2 &lt;- rnorm(N) y = 1.5 + 2*X1 + 3*X2 + rnorm(N) df &lt;- data.frame( y, X1, X2 ) f &lt;- y ~ X1 + X2 ols(df, f) ## [,1] ## [1,] 1.496133 ## [2,] 1.978201 ## [3,] 2.981712 ols(df, f, &quot;matrix&quot;) ## [,1] ## (Intercept) 1.496133 ## X1 1.978201 ## X2 2.981712 summary(lm(f, df)) ## ## Call: ## lm(formula = f, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.1968 -0.6336 0.0163 0.6654 3.4847 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.49613 0.03259 45.91 &lt;2e-16 *** ## X1 1.97820 0.03251 60.84 &lt;2e-16 *** ## X2 2.98171 0.03306 90.20 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.03 on 997 degrees of freedom ## Multiple R-squared: 0.923, Adjusted R-squared: 0.9228 ## F-statistic: 5974 on 2 and 997 DF, p-value: &lt; 2.2e-16 "],["logit.html", "Logit", " Logit inv_logit &lt;- function(x) { p &lt;- 1 / (1 + exp(-x)) return(p) } logit &lt;- function(data, formula, na.action=na.exclude) { mf &lt;- model.frame(formula, data, na.action=na.action) Y &lt;- model.response(mf, type=&quot;double&quot;) X &lt;- model.matrix(formula, mf) B &lt;- numeric(ncol(X)) logitll &lt;- function(B) { p &lt;- inv_logit((X %*% B)) lli &lt;- Y*log(p) + (1-Y)*log(1-p) return(-sum(lli)) } est &lt;- optim(B, logitll, method=&quot;BFGS&quot;) return(est$par) } Testing the function: set.seed(42) N &lt;- 1000 X1 &lt;- rnorm(N) X2 &lt;- rnorm(N) ystar &lt;- 1.5 + 2*X1 + 3*X2 + rnorm(N) y &lt;- rbinom(N, 1, inv_logit(ystar)) df &lt;- data.frame( y, X1, X2 ) f &lt;- y ~ X1 + X2 summary(glm(f,binomial,df))$coef ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 1.413335 0.1203875 11.73988 7.960399e-32 ## X1 1.839204 0.1439189 12.77945 2.135770e-37 ## X2 2.472301 0.1728920 14.29968 2.198073e-46 logit(df, f) ## [1] 1.413368 1.839245 2.472373 "],["ordered-logit.html", "Ordered Logit", " Ordered Logit inv_logit &lt;- function(x) { p &lt;- 1 / (1 + exp(-x)) return(p) } ologit &lt;- function(data, formula, na.action=na.exclude) { mf &lt;- model.frame(formula, data, na.action=na.action) Y &lt;- model.response(mf) X &lt;- model.matrix(formula, mf)[,-1] N &lt;- nrow(X) levels &lt;- unique(Y) M &lt;- length(levels) ncut &lt;- M-1 c &lt;- 1:ncut/M b &lt;- numeric(ncol(X)) par &lt;- c(c,b) ologitLL &lt;- function(param) { c &lt;- param[1:ncut] b &lt;- param[(ncut+1):length(param)] Xb &lt;- X %*% b lli &lt;- numeric(N) for (m in 1:M) { if (m == 1) { lli[Y==levels[m]] &lt;- log(inv_logit(c[m]-Xb[Y==levels[m]])) } else if (m &lt; M) { lli[Y==levels[m]] &lt;- log(inv_logit(c[m]-Xb[Y==levels[m]]) - inv_logit(c[m-1]-Xb[Y==levels[m]])) } else { lli[Y==levels[m]] &lt;- log(1 - inv_logit(c[m-1]-Xb[Y==levels[m]])) } } return(-sum(lli)) } out &lt;- optim(par, ologitLL, method=&quot;BFGS&quot;) est &lt;- out$par names(est)[1:ncut] &lt;- paste0(&quot;t&quot;, 1:ncut) names(est)[(ncut+1):length(est)] &lt;- colnames(X) return(est) } Testing the function: # Example from https://towardsdatascience.com/implementing-and-interpreting-ordinal-logistic-regression-1ee699274cf5 library(carData) library(MASS) data(WVS) f &lt;- poverty~religion+degree+country+age+gender summary(polr(f, WVS)) ## ## Re-fitting to get Hessian ## Call: ## polr(formula = f, data = WVS) ## ## Coefficients: ## Value Std. Error t value ## religionyes 0.17973 0.077346 2.324 ## degreeyes 0.14092 0.066193 2.129 ## countryNorway -0.32235 0.073766 -4.370 ## countrySweden -0.60330 0.079494 -7.589 ## countryUSA 0.61777 0.070665 8.742 ## age 0.01114 0.001561 7.139 ## gendermale 0.17637 0.052972 3.329 ## ## Intercepts: ## Value Std. Error t value ## Too Little|About Right 0.7298 0.1041 7.0128 ## About Right|Too Much 2.5325 0.1103 22.9496 ## ## Residual Deviance: 10402.59 ## AIC: 10420.59 ologit(WVS, f) ## Warning in log(inv_logit(c[m] - Xb[Y == levels[m]]) - inv_logit(c[m - 1] - : ## NaNs produced ## Warning in log(inv_logit(c[m] - Xb[Y == levels[m]]) - inv_logit(c[m - 1] - : ## NaNs produced ## Warning in log(inv_logit(c[m] - Xb[Y == levels[m]]) - inv_logit(c[m - 1] - : ## NaNs produced ## t1 t2 religionyes degreeyes countryNorway ## 0.72937251 2.53210358 0.17978268 0.14087551 -0.32235825 ## countrySweden countryUSA age gendermale ## -0.60330084 0.61782030 0.01113128 0.17637937 "],["multinomial-logit.html", "Multinomial Logit", " Multinomial Logit mnlogit &lt;- function(data, formula, na.action=na.exclude) { mf &lt;- model.frame(formula, data, na.action=na.action) y &lt;- model.response(mf) X &lt;- model.matrix(formula, mf) N &lt;- nrow(X) K &lt;- ncol(X) levels &lt;- unique(y) M &lt;- length(levels) Y &lt;- matrix(N*M, nrow=N, ncol=M) for (m in 1:M) { Y[,m] &lt;- ifelse(y==levels[m], 1, 0) } b &lt;- numeric(K*(M-1)) mnlogitLL &lt;- function(param) { b &lt;- matrix(param, nrow=K, ncol=M-1) Xb &lt;- cbind(rep(0, N), X %*% b) lli &lt;- numeric(N) for (m in 1:M) { lli &lt;- lli + Y[,m]*Xb[,m] - Y[,m]*log(rowSums(exp(Xb))) } return(-sum(lli)) } out &lt;- optim(b, mnlogitLL, method=&quot;BFGS&quot;) est &lt;- matrix(out$par, nrow=K, ncol=M-1) rownames(est) &lt;- colnames(X) colnames(est) &lt;- paste0(levels[1], &quot;/&quot;, levels[2:M]) return(est) } Testing the function: library(mclogit) ## Loading required package: Matrix housing &lt;- MASS::housing #has an ordinal outcome but we&#39;ll ignore that for our purposes f &lt;- Sat ~ Infl + Freq + Type t(mblogit(f, data = housing)$coefmat) ## ## Iteration 1 - deviance = 150.7444 - criterion = 0.5116897 ## Iteration 2 - deviance = 150.511 - criterion = 0.001549817 ## Iteration 3 - deviance = 150.5107 - criterion = 1.965799e-06 ## Iteration 4 - deviance = 150.5107 - criterion = 3.804011e-12 ## converged ## Response categories ## Predictors Medium High ## (Intercept) 1.1352190 -0.740346318 ## InflMedium 0.1291512 0.005033149 ## InflHigh -0.4256812 0.282489556 ## Freq -0.0501481 0.026990219 ## TypeApartment 0.8092387 -0.644372087 ## TypeAtrium -0.4053420 0.264568900 ## TypeTerrace -0.3689781 0.189799430 mnlogit(housing, f) ## Low/Medium Low/High ## (Intercept) 1.13582927 -0.740243313 ## InflMedium 0.12920635 0.005028019 ## InflHigh -0.42591879 0.282447109 ## Freq -0.05017388 0.026985033 ## TypeApartment 0.80963960 -0.644298089 ## TypeAtrium -0.40569533 0.264391915 ## TypeTerrace -0.36904115 0.189905490 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
